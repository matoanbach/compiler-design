# Symbol tables
## Symbol tables: processing declarations
- One of the objectives of the compiler is to verify that identifiers are properly used according to their specifications:
    - Variables used according to their declaration (type, dimensionality)
    - Functions called according to their declarations (return type, number and type of parameters)
    - Objects are using members as declared in their class declaration
    - Variables/functions are only used in the scope in which they were declared

- In `manifestly-typed languages`, all identifiers have a declaration that specifies the types that they are statically bound to:
    - Class and/or data structure declaration (global or embedded). Represent user-defined data types.
    - Variable declaration (global/local variables, class/data structure members)
    - Function declaration (free function, member function, embedded function)

- Other languages minimize declarations by omitting types
    - Often referred to as `dynamic languages`
    - Limited analysis can still be done at compile-time, e.g. type inference
    - Some of the analysis has to be delayed to run-time

- In the project, our language is manifestly-typed.

## Symbol tables: processing declarations: tree traversal
- Declarations are processed as a tree is traversed:
    - We have an Abstract Syntax Tree intermediate representation that was previously generated by the parsing phase.
    - We traverse this AST to process the declarations that are in the source program and create a `symbol table structure` that represents each scope of the program and then for each individual scope we store a `symbol table record` for all identifers declared within the scope.

- The processing of the declarations is made by aggregating and processing semantic information that is present at the leaves of the tree, and migrated/processed by intermediate nodes of the tree.
- This migration/aggregation/processing is done using `semantic actions` that are triggered as the tree is traversed.
- Specific semantic actions should be triggered when certain specific kind of nodes are reached as the tree is traversed.
- If the processing is done upon an intermediate representation (e.g. an AST), further processing can be done in successive traversal passes, where each traversal pass is responsible for a specific part of the analysis/translation process.

# Symbol table structure
## Symbol tables: scopes
- Generally, every scope defined in the language/program requires its own symbol table.
    - The global scope contains an entry for all identifiers declared outside of any scope, e.g. global variables, globally-declared classes or data structures, free functions, etc.
    - Some named scopes (e.g. classes, functions) allow some identifiers to be declared, e.g. local variables, or even inner classes or inner functions - if present in the language.
    - Some scopes are not named, e.g. a `for loop`'s statement block - these can also define their own sub-scope and corresponding sub-symbol table - out of simplicity for the project, it is suggested that you don't implement local symbol tables for unnamed statement blocks.

## Symbol tables: procedures to implement
- `CreateNewTable` - when a new scope is entered, a new empty symbol table is created, as well as the symbol table entry to be recorded in the higher-level symbol table
- `Insert` - while in a scope, for every declaration encountered, a symbol table record is created and inserted.
- `Search` - when an identifier is referred to in a scope, the compiler needs to check if it has been previously declared, either in the current scope or one of its higher-level scopes. This requires a search method that searches across a table hierarchy. If information hiding descriptors are part of the language, they must be taken into consideration here.
- `Print` - for utility, a facility to output a symbol table, along with its sub-tables.
- `Delete` - some scopes cannot be referred to outside of their scopes. In which case their symbol tables may be deleted, for efficiency. Some scopes, e.g. classes can be referred to from outside their own scope. These should be kept until the end of the compilation process.

## Tree traversal and sematic actions: example
- `Semantic actions` should be executed as the tree is traversed, either as the node is first reached, or as soon as each node's subtree has been fully traversed.
- Each node may potentially have to execute zero to several semantic actions. It may seem appropriate to define semantic actions as member functions of each node classes.
- However, some semantic actions require actions from other semantic actions to have taken place before.
- Thus, semantic actions have to be grouped into `traversal passes`, AND still be mapped to specific nodes.
- The `visitor design pattern` is a structure that achieves all of this.

# Visitor Pattern
## Visitor Pattern: description
- Motivation:
    - When many new operations are needed and an object structure consist of many different classes, it is inflexible to add new subclasses each time a new operation is required.
    - Distributing all these new operations across the various classes leads to a system that's hard to understand, maintain, and change.
    - Often, the new operations form groups that are related to cohesive groups of operations.
        - Adding all of them in the same existing classes creates low cohesion.
        - Often, only speific syb-groups of operations should be triggered.
- Intent:
    - To create a structure/mechanism by which new operations are injected into existing classes, with minimal changes to be applied to these classes.
    - To provide modularity and cohesion by creating groups of related new operations.
    - Be able to inject/execute only a specific group of operations at a time.

## Visitor Pattern: structure
- The classes/object participating in the visitor pattern:
    - `Elements` - Superclass of all the objects that are to be injected with new behavior.
    - `ConcretElement` - All of the specific classes into which the new behavior is to be injected.
    - `Visitor` - Superlcass of all injectable behavior groups.
    - `ConcreteVisitor` - specific injectable behavior group.
    - `Client` - piece of code that usese a group/structure of elements and wants to inject/execute new behavior in them.

# AST vistor
## AST visitor: symbol tables creation - concept
- Each `scope` in the program should have its own symbol table
    - global, class, function definition: member function, free function, main function
    - When we visit one of these node types:
        - `Upon entry into this node`: Create a new local symbol table that is a new data member of this node
        - `Once the whole sub tree of this node has been traversed`: aggregate locally defined id declarations' symbol table records from its children subtrees and put them in the symbol table.
- Inside each scope, identifiers are declared:
    - `class`: data/function members
    - `function body`: local variables, parameters
    - When we visit one of these node types:
        - Create a symbol table record
        - It will be picked-up by the parent node's semantic action when all its subtress will have been traversed/processed (as done in the previous two slides)

# AST Visitors for semantic checking
## Semantic checking
- Multiply declared identifiers
    - Detected when we insert the symbol table records
- Undeclared identifiers
    - As identifiers (variable or function) are encountered during the parsing of e.g. expression, check if the identifier is declared in the current scope, or in the class it should be in, or one of its superclasses.
    - For function calls, 3 cases: 
        - Function id does not exist in the scope in which it is called (or higher-level scope)
        - Number of parameters does not match the function defined in this scope.
        - Type of expressions passed as parameters does not match any function declared in this scope.
    - For variables, 3 cases:
        - Variable id does not exist in the current scope (or high-level scope).
        - Number of dimensions used does not match the number of dimensions as declared.
        - An id uses the `.openator` on a member that is undefined in its class's type or its superclasses.
- Type checking
    - Operators' operand types are invalid
    - Type of expresions passed as parameters do not match the function's parameter type.
    - Type of an assignment statement's right and left hand side do not match.
    - Return statement does not match return type of the function.
